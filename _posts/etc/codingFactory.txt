1장 스프링 시작하기
1.1 스프링의 새로운 시작
-> 스프링은 JEE나 J2EE로 알려진 자바 엔터프라이즈 에디션을 경량화하려는 대안으로 시작
컴포너느 코드 작성은 가벼웠으나 개발 구성은 무거웠다. (초기 스프링은 구성에 필요한 XML 코드가 많았다. 
스프링 2.5는 네어테이션을 기반으로 한 컴포너느 검색 기능 도입 XML 구성을 상당 부분 제서했다.
스프링 3.0에서는 XML 대신 타입 세이트하고 리패고링이 가능한 자바 기반의 구성을 도입)

모든 구성 작업은 개발 저항으로 나타난다. 
애플리케이션 로직 작성 대신 구성 작업에 쓰는 시간은 모두 낭비다.
스프링은 많은 일을 대신 처리하지만, 그 대가로 여러브분이 해야 할 일도 늘어난다.

라이브러리 상호 의존성을 모두 지키는 부분은 생각 보다 까다 롭다.(의존성 관리)

Hello World 웹 애플리케이션을 개발한다고 하자.
스프링에서는....
- 필요한 의존성을 비롯한 메이븐이나 그레이들 빌드 파일이 완비된 프로젝트 구조, 적어도 스프링 MVX와 서블릿 API를 의존성으로 지정해야 한다. 
- 스프링의 DispatcherServlet을 선언한 web.xml 파일 또는 WebApplicationInitializer 구현
- 스프링 MVC를 사용할 수 있는 스프링 구성
- HTTP 요청에 "Hello World"라고 응갑할 컨트롤러 클래스
- 애플리케이션을 배포할 웹 애플리케이션 서버(톰캣 등)

그루비 언어로 하게 되면 Controller만 작성하면 됨

1.1.2 스프링 부트 핵심 비법
- 자동 구성 : 스프링 부트는 많은 스프링 애플리케이션에 공통으로 필요한 애플리케이션 기능을 자동으로 구선
- 스타터 의존성 : 스프링 부트에 어떤 기능이 필요한지 알려주면 필요한 라이브러리를 빌드에 추가한다는 것을 보장한다.
예를 들어 REST API를 스프링 MVC로 만든다고 사정하자.
* org.springframework:spring-core
* org.springframework:spring-web 
* org.springframework:spring-webmvc 
* org.fasterxml.jackson.core:jackson-databind
* org.hibernate:hibernate-validator 
* org.apache.tomcat.embed:tomcat-embed-core
* org.apache.tomcat.embed:tomcat-embed-el
* org.apache.tomcat.embed:tomcat-embed-logging-juli

* org.springframework.boot:spring-boot-starter-web (다른 의존성을 전이적으로 모두 끌어오므로 의존성 전체를 일일이 추가할 필요가 없다.)

- 명령줄 인터페이스 : 스프링 부트의 이 부가 기능을 이용하면 애플리케이션 코드만 작성해도 완전한 애플리케이션을 개발할 수 있지만, 기존 프로젝트 빌드 방식에는 필요 없는 기능이다. 
- 액추에이터 : 스프링 부트 애플리케이션을 실핼할 때 내부에서 어떤 일이 일어나는지 이해할 수 있다.
* 스프링 애플리케이션 컨텍스트에 구성된 빈
* 스프링 부트의 자동 구성으로 구성된 것
* 애플리케이션에서 사용할 수 있는 환경 변수, 시스템 프로퍼티, 구성 프로퍼티, 명령줄 인자
* 최근에 처리된 HTTP 요청 정보
* 메모리 사용량, 가비지 컬렉션, 웹 요청, 데이터 소스 사용량 등 다양한 메트릭


*** 보일러 플레이트 

보일러판(boilerplate)은 주간 신문들의 공통 기사나 진부하게 사용된 문장을 의미한다.

 컴퓨터 프로그래밍에서 보일러판(boilerplate)은 작지만 대체할수 없고, 여러곳에 포함되어야 하는 코드 섹션을 설명하는 데 쓰이는 용어다. 이 용어는 verbose한 언어를 말할때 종종 사용한다. (예, 프로그래머가 매우 작은 일을 하기 위해서 많은 코드를 작성해야 하는 경우) 보일러플레이트의 사용은 메타 프로그래밍이나 convention over configuration같은  high-level 메커니즘을 통해서 줄일 수 있다. 


출처: http://julingks.tistory.com/entry/Boilerplate-code [My Tech Notes]

c 프로그램에서는 매우 자주 포함되는 라이브러리를 include하는 다음과 같은 코드들이다.
#include <stdio.h>
#include <stdlib.h>


출처: http://julingks.tistory.com/entry/Boilerplate-code [My Tech Notes]

객체 지향 프로그래밍에서 클래스들은 인스턴스 변수의 getter와 setter 메소드들을 포함한다.  이 메소드들의 정의들은 종종 보일러플레이트로 여겨진다. 이런 코드는 클래스마다 다를지라도 충분히 틀에박혀 있는 전형적인 구조들이다. 

출처: http://julingks.tistory.com/entry/Boilerplate-code [My Tech Notes]

# con
스프링 부트는 프레임워크 자체에 저항을 최소화하면서 스프링 애플리케이션을 개발할 수 있는 흥미진진하고 새로운 방법이다. 
자동 구성은 전통적인 스프링 애플리케이션에 있던 많은 보일러 플레이ㅡ 구성을 제거했다. 
스프링 부트 스타터는 명시적인 라이브러리 이름이나 버전 대신에 스프링 부트가 제공하는 기능으로 빌드 의존성을 지정할 수 있게 했다. 
스ㅡ링 부트 CLI는 명령줄에서 그루비를 사용하고 빠르고 간편하게 개발할 수 있게 하여 스프링 부트의 저항 없는 개발 모델을 완전히 새로운 수준으로 끌어올렸다. 
그리고 액추에이터는 작동 중인 애플리케이션 내부를 살펴보면서 스프링 부트가 어떤 식으로 처리하는지 알 수 있게 했다. 


2장

@springBootApplication -> 스프링 컴포너느 검색과 스프링 부트 자동 구성을 활성화
- @configuration -> 스프링의 자바 기반 구성 클래스로 지정한다. 
- @componentScan -> 컴포넌트 검색 기능을 활성화해서 웹 컨트롤러 클래스나 다른 컴포넌트 클래스들을 자동으로 검색하여 스프링 애플리케이션 컨텍스트에 빈으로 등록시킨다. 
( 잠시 후 간단한 스프링 MVC 컨트롤러를 작성하면서 @Controller 애너테이션을 붙여 컴포넌트 검색이 이 컨트롤러를 찾을 수 있게 할 것이다. )
- @EnableAutoConfiguration : @Abracadabra와 같은 의미로 스프링 부트의 자동 구성 설정
이외에 추가 구성이 필요하다면 @Configuration 에너테이션을 포함한 구성 클래스에서 작성하는 것이 가장 좋다.
( 이 구성 클래스등은 컴포넌트 검색으로 자동으로 추가한다. )

pom.xml
프로젝트에 부모 스타터를 지정하면 메이븐의 의존성 관리 기능으로 자주 사용하는 라이브러리들의 의존성 버전을 상속받을 수 있어서 의존성을 선언할 때 버전을 명시하지 않아도 된다. 

2.2 스타터 의존성 사용하기

Tyhymeleaf 뷰와 이 뷰의 데이터를 JPA로 저장하는 스프링 웹 애플리케이션을 개발하고 싶을 뿐읻.  하지만 코드 첫 줄을 작성하기도 전에 빌드 명세에 어떤 것을 추가하여 기능을 만들어야 할지를 고민해야 한다. 
Thymeleaf의 그룹 ID와 이티팩트 ID는 기억나는가? 스프링 데이터  JPA의 어떤 버전을 사용해야 할까? 이 모든 의존성은 서로 잘 호환이 될까?

만약 작성했다고 하더라도 그것이 잘 작성되었는지 어떻게 할 수 있을까? 선택한 의존성 버전끼리 서로 잘 호환되는지 어떨게 장담할 수 있을까? 물론 잘될 수도 있지만, 애플리케이션을 빌드하고 실행하기 전까지는 확실히 알 수 없을 것이다. 
스타터 의존성 버전은 사용하는 스프링 부트 버전에 따라 결정된다. 또 스타터 의존성은 추가로 가져오는 다양한 전이적 의존성 버전도 자체적으로 결정한다. 사용하는 여러 라이브러리의 버전을 몰라서 불안할 수도  있다. 하지만 스프링 부트는 사용할 모든 의존성 간에 호환성을 보장하도록 테스트를 마쳤다. 
그럼에도 스타터 의존성이 가져오는 전이적 의존성 버전을 알아야겠다면 빌드 도구를 이용한다. 
--- gradle dependencies
--- mvn dependency:tree

2.2.2
스타터 의존성은 빌드에 있는 다른 의존성처럼 의존성일 뿐이다. 이는 빌드 도구로 전이적 의존성 버전을 선택적으로 오버라이드할 수 있고, 전이적 의존성들을 제외할 수 있으며, 스프링 부트 스타터가 포함하지 않는 라이브러리에 의존성을 확실하게 지정할 수 있다는 의미다. 
메이븐에서는 exclusions 요소를 사용하여 전이적 의존성을 제외할 수 있다. 가급적이면 새로운 버전에서 버그를 고칠 때 같은 특별한 상황에서만 전이적 의존성을 오버라이드하는 것이 좋다. 

2.3
스프링 부트 자동 구성은 스프링 구성을 적용해야 할지 말지를 결정하는 요인들을 판단하는 런타임 과정이라고 할수 있다. 
예를 들어
- 클래스패스에 jdbcTemplate이 있고 DataSource 빈이 있다면 JdbcTemplate 빈을 자동 구성한다. 
- 클래스패스에 Thymeleaf가 있다면 Tyhmeleaf템플릿 리졸버, 뷰 리졸버, 템플릿 엔진을 구성한다. 
- 클래스패스에 스프링 시큐리티가 있다면 아주 기본적인 웹 보안을 구성한다. 

# con
스타터 의존성은 특정 라이브러리나 버전보다는 애플리케이션에 필요한 기능 유형에 집중할 수 있게 한다. 게다가 자동 구성을 이용하면 스프링 부트를 사용하지 않은 스프링 애플리케이션에서 흔히 했던 보일러플레이트 구성을 직접 하지 않아도 된다. 
그러나 스프링을 다르게 구성하고 싶거나 그렇게 해야 하는 상황이라면 어떻게 해야할까 다음장에서 살펴보잣

3.1 스프링 피자 토핑 / 스프링 부트 불고기 피자

대체로 자동 구성된 빈은 우너하는 것을 정확하게 제공하므로 오버라이드할 필요가 없다. 하지만 자동 구성으로 원하는 기능이 잘 작동하지 않을 때도 있다. 
대표적인 예로 애플리케이션에 보안을 적용할 때 자동 구성은 적합하지 않다. 보안은 한 번에 완성할 수 없으며 애플리케이션 보안에 필요한 많은 결정을 스프링 부트가 다 하지 못하기 때문이다.
설령 스프링 부트가 일부 기본적인 자동 보안 구성을 하더라도 원하는 상세한 보안 요구 사항을 만족하려면 오버라이드할 수 밖에 없을 것이다. 

예제 - 시큐리티 스타터

스프링 보안을 구성하는 방법을 약간 바꾸고 싶다. 로그인 페이지를 수정하고 데이터베이스나 LDAP 기반 사용자 저장소를 이용하여 작동하는 인증 서비스를 제공하고 싶다. 

WebSecurityConfigurerAdapter를 확장해서 구성 클래스를 작성한다. 
작성한 SecurityConfig는 아주 기본적인 스프링 시큐리티 구성이다. 
이렇게 사용자 정의 보안 구성 클래스를 선언하면 스프링부트는 보안 자동 구성을 건너뛴 채 사용자 정의 보안 구성을 사용한다. 
스프링 시큐리티는 JDBC 기반, LDAP 기반, 인메모리 사용자 저장소를 포함한 몇 가지 인증 옵션을 제공한다. 예제에서는 JPA를 이용한 데이터베이스를 기반으로 사용자를 인증한다. 
85 페이지 참고

결론은 스프링 부트 자동 구성을 오버라이드하려면 명시적인 구성만 작성하면 된다. 스프링 부트에서 명시적인 구성을 발견하면 자동 구성보다는 명시적인 구성을 우선적으로 반영한다. 
스프링 부트 자동 구성의 이면을 살펴보면서 자동 구성이 어떻게 작동하고 어떤 식으로 오버라이드를 허용하는지 알아보자.


스프링 부트 애플리케이션에 프로퍼티를 설정하는 방법은 여러 가지이다. 
1. 명령줄 인자. 
2. java:comp/env에서 얻을 수 있는 JNDI 속성
3. JVM 시스템 프로퍼티
4. 운영체제의 환경 변수
5. random.*로 시작하는 프로퍼티 때문에 무작위로 생성된 값(${random.long}처럼 다른 프로퍼티를 설정할 때 참조)
6. 애플리케이션 외부에 있는 application.properties나 application.yml 파일
7. 애플리케이션 내부에 패키징된 application.properties나 application.yml 파일
8. @PropertySource로 지정된 프로퍼티 소스
9. 기본 프로퍼티

이 목록은 우선순위 순으로 작성되었다. 

application.properties와 application.yml 파일은 다음 네 곳 어디에나 배치할 수 있다. 
1. 외부적으로 애플리케이션이 작동하는 디렉터리의 /config 하위 디렉터리
2. 외부적으로 애플리케이션이 작동하는 디렉터리
3. 내부적으로 config 패키지
4. 내부적으로 클래스패스의 루트

이 목록도 우선순위가 있고 우선순위가 동일한 레벨 안에 properties와 yml중에는 yml 내용이 프로퍼티를 오버라이드 한다. 

유용한 프로퍼티
- spring.thymeleaf.cache : 개발하는 동안 실시간 반영되도록 캐싱 하지 않음 (프리마커 그루비 벨로시키도 있음 - 모두 기본 설정은 true)
- server.port 
- https setup 
- logging.level.root : 로그 레벨을 설정
** log4j나 log4j2를 사용한다면 해당 구현체에 대응하는 적당한 ㅅ타터를 추가하고, 의존성을 변경하여 로그백을 제외시켜야 한다. 

108페이지
@Profile 애너테이션은 production 프로파일을 런타임에서 활성화했을 때만 해당 구성을 적용함(보안같은경우 로컬에서는 해당 안될 경우에는 이런 옵션이 필요)
또는 spring.profiles.active : production도 가능
또는 application-{profile}.properties 형태의 추가적인 프로퍼티 파일을 생성하여 프로파일에 특화된 프로퍼티를 제공할 수 있다. 
yml 경우에는 하이픈 세개(---)를 사용하여 부분을 나눌수 있다. 

112페이지
스프링 부트는 자동 구성을 이용하여 '화이트라벨' 오류 페이지를 기본으로 제공한다. 
스프링 부트가 자동으로 구성한 기본 오류 핸들러는 'error'뷰를 찾는다. 
결국 사용자 정의할 뷰는 다음과 같이 오류 뷰를 해석할 때 사용될 뷰 리졸버에 따라 달라진다. 
- 스프링의 View 인터페이스를 구현하여 ID가 'error'인 빈
- Thymeleaf를 사용한다면 Thymeleaf 템플릿 error.html
- FreeMarker를 사용한다면 FreeMarker 템플릿 error.fasterxml
- Velocity를 사용한다면 Velocity 템플릿 error.JVM
- JSP를 사용한다면 JSP 템플릿 error.JSP

con
스프링 부트는 스프링 애플리케이션에 요구되는 보일러플레이트 구성을 대부분 제거한다. 하지만 모든 구성을 스프링 부트에 위임하면 스프링 부트가 애플리케이션에 필요한 컴포넌트 구성을 결정한다. 
자동 구성이 요구 사항에 적합하지 않을 때를 대비하여 스프링 부트는 구성을 오버라이드하거나 상세한 부분을 변경할 방법을 제공한다. 


스프링 부트 애플리케이션 개발자에게는 웹 애플리케이션을 테스트할 수 있는 두 가지 옵션이 있다. 
Mock MVC를 설정하려면 MockMvcBuilders를 사용한다. 이 클래스는 정적 메서드 두 개를 제공한다. 
- standaloneSetup() : 수동으로 생성하고 구성한 컨트롤러 한 개 이상을 서비스할 Mock MVC를 만든다. 
- webAppContextSetup() : 구성된 컨트롤러 한 개 이상을 포함하는 스프링 애플리케이션 컨텍스트를 사용하여 Mock MVC를 만든다. 
이 두 옵션의 가장 큰 차이는 standaloneSetup() 메서드는 테스트할 컨트롤러를 수동으로 초기화하고 주입하기를 기대하는 반면,
webAppContextSetup() 메서드는 (스프링이 로드한) WebApplicationContext의 인스턴스로 작동한다는 점이다. standaloneSetup() 메서드는 한 컨트롤러에 집중하여 테스트하는 용도로만 사용한다는 점에서 
유닉 테스트와 유사하다. 
반면에 webAppContextSetup() 메서드는 스프링이 커느롤러는 물론 의존성까지 로드하여 완전한 통합 테스트를 할 수 있게 한다. 

128페이지
springSecurity() 메서드는 Mock MVC용으로 스프링 시큐리티를 활성화하는 Mock MVC 구성자를 반환한다. 
그렇다면 어떻게 이ㅏㄴ증된 요청을 수행할 수 있을까?
- @WithMockUser : 지정한 사용자 이름, 패스워드, 권한으로 UserDetails를 생성한 후 보안 컨텍스트를 로드한다. 
- @WithUserDetails : 지정한 사용자 이름으로 UserDetails 객체를 조회하여 보안 컨텍스트를 로드한다. 

+++++++++

@WebIntegrationTest 애너테이션을 붙이면 스프링 부트가 테스트용 애플리케이션 컨텍스트를 생성하면서 내장 서블릿 컨테이너도 시작한다. 애플리케이션을 내장 컨테이너와 함께 실행하고나면 이를 대상으로 실제 http 요청을 보낼 수 있고 결과를 검증할 수 있다. 
별도의 포트를 설정할 수 있음
@WebIntegrationTest(value={ "server.port=0"})


---------------------------

7.1 191 페이지

스프링 부트 액추에이터의 핵심 기능은 실행중인 애플리케이션 내부를 볼 수 있게 하는 여러 웹 엔드포인트를 애플리케이션에서 제공하는 것이다. 
액추에이터를 이용하면 스프링 애플리케이션 컨텍스트의 빈들을 어떻게 연결했고, 애플리케이션에서 어떤 환경 프로퍼티를 사용할 수 있는지 확인할 수 있으며,
런타임 메트릭의 스냅샷도 확보할 수 있다. 

191 페이지 표 7-1 참조(액추에이터 엔드포인트)

액추에이터 추가(메이븐)
스프링 부트 자동 구성은 스프링 구성이 더은데도 이 문제를 더욱 악화시킨다. 적어도 명시적 구성ㅇ로는 XML 파일이나 구성 클래스를 들여다보고, 스프링 애플리케이션 컨텍스트에 있는 빈 사이의 관계를 파악할 수 있었다. 
애플리케이션의 스프링 컨텍스트를 살펴볼 수 있는 가장 핵심적인 엔드포인트는 /beans이다. 

203 페이지 표 7-2 /metrics 엔드포인트로 보여 주는 게이지와 카운터

애플리케이션을 실행하여 현재 구동 중인지 알고 싶을 때는 /health 엔드포이느를 요청하여 간편하게 확인할 수 있다. 
/health 앤드포인트가 제공하는 일부 정보는 민감할 수 있으므로 인증되지 않은 요청에는 단순한 상태만 응답으로 보낸다. 
208 페이지 표 7-3 스프링 부트의 특별한 헬스 인디케이터

/info 엔드포인트는 호출자에게 알리고 싶은 모든 애플리케이션 정보를 보여 준다. 
appliation.yml 에 info.ccontactEmail 프로퍼티를 다음과 같이 설정한다. 
/info 엔드포인트에 프로퍼티를 추가하는 것은 애구에이터 작동을 사용자 정의하는 수많은 방법 중 하나에 불과하다. 

스프링 부트는 CRaSH를 내장하고 있는데 이 셸은 어떤 자바 애플리케이션에서든 내장할 수 있다. 
메이븐에 의존성 추가한다. remote-shell

비록 액추에이터로 실행 중인 스프링 부트 애플리케이션의 내부 작동을 살펴볼 수 있더라도 모든 요건을 완벽히 출족하지는 못할 것이다. 
액추에이터는 다양한 방법으로 사용자화할 수 있다. 
- 엔드포인트 이름 변경
- 엔드포인트 활성화/비활성화
- 사용자 메트릭과 게이지 정의
- 트레이스 데이터를 저장할 사용자 정의 리포지토리 생성
- 사용자 정의 헬스 인디케이터 추가


페이지 229 코드 7-13
도서 목록 애플리케이션의 도서 목록에 등록된 책은 아마존으로 이동하는 링크를 포함하므로 아마존에 접속이 가능한지 보고하면 흥미로울 것이다.
아마존의 상태를 표시하는 HealthIndicator 구현체를 작성해보자.

페이지 231

군한이 있는 관리자만 접근할 수 있도록 엑추에이터에 보안을 적용할 수 있다. (ex. /shutdown)




