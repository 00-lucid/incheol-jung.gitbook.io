1장 스프링 시작하기
1.1 스프링의 새로운 시작
-> 스프링은 JEE나 J2EE로 알려진 자바 엔터프라이즈 에디션을 경량화하려는 대안으로 시작
컴포너느 코드 작성은 가벼웠으나 개발 구성은 무거웠다. (초기 스프링은 구성에 필요한 XML 코드가 많았다. 
스프링 2.5는 네어테이션을 기반으로 한 컴포너느 검색 기능 도입 XML 구성을 상당 부분 제서했다.
스프링 3.0에서는 XML 대신 타입 세이트하고 리패고링이 가능한 자바 기반의 구성을 도입)

모든 구성 작업은 개발 저항으로 나타난다. 
애플리케이션 로직 작성 대신 구성 작업에 쓰는 시간은 모두 낭비다.
스프링은 많은 일을 대신 처리하지만, 그 대가로 여러브분이 해야 할 일도 늘어난다.

라이브러리 상호 의존성을 모두 지키는 부분은 생각 보다 까다 롭다.(의존성 관리)

Hello World 웹 애플리케이션을 개발한다고 하자.
스프링에서는....
- 필요한 의존성을 비롯한 메이븐이나 그레이들 빌드 파일이 완비된 프로젝트 구조, 적어도 스프링 MVX와 서블릿 API를 의존성으로 지정해야 한다. 
- 스프링의 DispatcherServlet을 선언한 web.xml 파일 또는 WebApplicationInitializer 구현
- 스프링 MVC를 사용할 수 있는 스프링 구성
- HTTP 요청에 "Hello World"라고 응갑할 컨트롤러 클래스
- 애플리케이션을 배포할 웹 애플리케이션 서버(톰캣 등)

그루비 언어로 하게 되면 Controller만 작성하면 됨

1.1.2 스프링 부트 핵심 비법
- 자동 구성 : 스프링 부트는 많은 스프링 애플리케이션에 공통으로 필요한 애플리케이션 기능을 자동으로 구선
- 스타터 의존성 : 스프링 부트에 어떤 기능이 필요한지 알려주면 필요한 라이브러리를 빌드에 추가한다는 것을 보장한다.
예를 들어 REST API를 스프링 MVC로 만든다고 사정하자.
* org.springframework:spring-core
* org.springframework:spring-web 
* org.springframework:spring-webmvc 
* org.fasterxml.jackson.core:jackson-databind
* org.hibernate:hibernate-validator 
* org.apache.tomcat.embed:tomcat-embed-core
* org.apache.tomcat.embed:tomcat-embed-el
* org.apache.tomcat.embed:tomcat-embed-logging-juli

* org.springframework.boot:spring-boot-starter-web (다른 의존성을 전이적으로 모두 끌어오므로 의존성 전체를 일일이 추가할 필요가 없다.)

- 명령줄 인터페이스 : 스프링 부트의 이 부가 기능을 이용하면 애플리케이션 코드만 작성해도 완전한 애플리케이션을 개발할 수 있지만, 기존 프로젝트 빌드 방식에는 필요 없는 기능이다. 
- 액추에이터 : 스프링 부트 애플리케이션을 실핼할 때 내부에서 어떤 일이 일어나는지 이해할 수 있다.
* 스프링 애플리케이션 컨텍스트에 구성된 빈
* 스프링 부트의 자동 구성으로 구성된 것
* 애플리케이션에서 사용할 수 있는 환경 변수, 시스템 프로퍼티, 구성 프로퍼티, 명령줄 인자
* 최근에 처리된 HTTP 요청 정보
* 메모리 사용량, 가비지 컬렉션, 웹 요청, 데이터 소스 사용량 등 다양한 메트릭


*** 보일러 플레이트 

보일러판(boilerplate)은 주간 신문들의 공통 기사나 진부하게 사용된 문장을 의미한다.

 컴퓨터 프로그래밍에서 보일러판(boilerplate)은 작지만 대체할수 없고, 여러곳에 포함되어야 하는 코드 섹션을 설명하는 데 쓰이는 용어다. 이 용어는 verbose한 언어를 말할때 종종 사용한다. (예, 프로그래머가 매우 작은 일을 하기 위해서 많은 코드를 작성해야 하는 경우) 보일러플레이트의 사용은 메타 프로그래밍이나 convention over configuration같은  high-level 메커니즘을 통해서 줄일 수 있다. 


출처: http://julingks.tistory.com/entry/Boilerplate-code [My Tech Notes]

c 프로그램에서는 매우 자주 포함되는 라이브러리를 include하는 다음과 같은 코드들이다.
#include <stdio.h>
#include <stdlib.h>


출처: http://julingks.tistory.com/entry/Boilerplate-code [My Tech Notes]

객체 지향 프로그래밍에서 클래스들은 인스턴스 변수의 getter와 setter 메소드들을 포함한다.  이 메소드들의 정의들은 종종 보일러플레이트로 여겨진다. 이런 코드는 클래스마다 다를지라도 충분히 틀에박혀 있는 전형적인 구조들이다. 

출처: http://julingks.tistory.com/entry/Boilerplate-code [My Tech Notes]

# con
스프링 부트는 프레임워크 자체에 저항을 최소화하면서 스프링 애플리케이션을 개발할 수 있는 흥미진진하고 새로운 방법이다. 
자동 구성은 전통적인 스프링 애플리케이션에 있던 많은 보일러 플레이ㅡ 구성을 제거했다. 
스프링 부트 스타터는 명시적인 라이브러리 이름이나 버전 대신에 스프링 부트가 제공하는 기능으로 빌드 의존성을 지정할 수 있게 했다. 
스ㅡ링 부트 CLI는 명령줄에서 그루비를 사용하고 빠르고 간편하게 개발할 수 있게 하여 스프링 부트의 저항 없는 개발 모델을 완전히 새로운 수준으로 끌어올렸다. 
그리고 액추에이터는 작동 중인 애플리케이션 내부를 살펴보면서 스프링 부트가 어떤 식으로 처리하는지 알 수 있게 했다. 


2장

@springBootApplication -> 스프링 컴포너느 검색과 스프링 부트 자동 구성을 활성화
- @configuration -> 스프링의 자바 기반 구성 클래스로 지정한다. 
- @componentScan -> 컴포넌트 검색 기능을 활성화해서 웹 컨트롤러 클래스나 다른 컴포넌트 클래스들을 자동으로 검색하여 스프링 애플리케이션 컨텍스트에 빈으로 등록시킨다. 
( 잠시 후 간단한 스프링 MVC 컨트롤러를 작성하면서 @Controller 애너테이션을 붙여 컴포넌트 검색이 이 컨트롤러를 찾을 수 있게 할 것이다. )
- @EnableAutoConfiguration : @Abracadabra와 같은 의미로 스프링 부트의 자동 구성 설정
이외에 추가 구성이 필요하다면 @Configuration 에너테이션을 포함한 구성 클래스에서 작성하는 것이 가장 좋다.
( 이 구성 클래스등은 컴포넌트 검색으로 자동으로 추가한다. )

pom.xml
프로젝트에 부모 스타터를 지정하면 메이븐의 의존성 관리 기능으로 자주 사용하는 라이브러리들의 의존성 버전을 상속받을 수 있어서 의존성을 선언할 때 버전을 명시하지 않아도 된다. 

2.2 스타터 의존성 사용하기

Tyhymeleaf 뷰와 이 뷰의 데이터를 JPA로 저장하는 스프링 웹 애플리케이션을 개발하고 싶을 뿐읻.  하지만 코드 첫 줄을 작성하기도 전에 빌드 명세에 어떤 것을 추가하여 기능을 만들어야 할지를 고민해야 한다. 
Thymeleaf의 그룹 ID와 이티팩트 ID는 기억나는가? 스프링 데이터  JPA의 어떤 버전을 사용해야 할까? 이 모든 의존성은 서로 잘 호환이 될까?

만약 작성했다고 하더라도 그것이 잘 작성되었는지 어떻게 할 수 있을까? 선택한 의존성 버전끼리 서로 잘 호환되는지 어떨게 장담할 수 있을까? 물론 잘될 수도 있지만, 애플리케이션을 빌드하고 실행하기 전까지는 확실히 알 수 없을 것이다. 
스타터 의존성 버전은 사용하는 스프링 부트 버전에 따라 결정된다. 또 스타터 의존성은 추가로 가져오는 다양한 전이적 의존성 버전도 자체적으로 결정한다. 사용하는 여러 라이브러리의 버전을 몰라서 불안할 수도  있다. 하지만 스프링 부트는 사용할 모든 의존성 간에 호환성을 보장하도록 테스트를 마쳤다. 
그럼에도 스타터 의존성이 가져오는 전이적 의존성 버전을 알아야겠다면 빌드 도구를 이용한다. 
--- gradle dependencies
--- mvn dependency:tree

2.2.2
스타터 의존성은 빌드에 있는 다른 의존성처럼 의존성일 뿐이다. 이는 빌드 도구로 전이적 의존성 버전을 선택적으로 오버라이드할 수 있고, 전이적 의존성들을 제외할 수 있으며, 스프링 부트 스타터가 포함하지 않는 라이브러리에 의존성을 확실하게 지정할 수 있다는 의미다. 
메이븐에서는 exclusions 요소를 사용하여 전이적 의존성을 제외할 수 있다. 가급적이면 새로운 버전에서 버그를 고칠 때 같은 특별한 상황에서만 전이적 의존성을 오버라이드하는 것이 좋다. 

2.3
스프링 부트 자동 구성은 스프링 구성을 적용해야 할지 말지를 결정하는 요인들을 판단하는 런타임 과정이라고 할수 있다. 
예를 들어
- 클래스패스에 jdbcTemplate이 있고 DataSource 빈이 있다면 JdbcTemplate 빈을 자동 구성한다. 
- 클래스패스에 Thymeleaf가 있다면 Tyhmeleaf템플릿 리졸버, 뷰 리졸버, 템플릿 엔진을 구성한다. 
- 클래스패스에 스프링 시큐리티가 있다면 아주 기본적인 웹 보안을 구성한다. 

# con
스타터 의존성은 특정 라이브러리나 버전보다는 애플리케이션에 필요한 기능 유형에 집중할 수 있게 한다. 게다가 자동 구성을 이용하면 스프링 부트를 사용하지 않은 스프링 애플리케이션에서 흔히 했던 보일러플레이트 구성을 직접 하지 않아도 된다. 
그러나 스프링을 다르게 구성하고 싶거나 그렇게 해야 하는 상황이라면 어떻게 해야할까 다음장에서 살펴보잣

3.1 스프링 피자 토핑 / 스프링 부트 불고기 피자

대체로 자동 구성된 빈은 우너하는 것을 정확하게 제공하므로 오버라이드할 필요가 없다. 하지만 자동 구성으로 원하는 기능이 잘 작동하지 않을 때도 있다. 
대표적인 예로 애플리케이션에 보안을 적용할 때 자동 구성은 적합하지 않다. 보안은 한 번에 완성할 수 없으며 애플리케이션 보안에 필요한 많은 결정을 스프링 부트가 다 하지 못하기 때문이다.
설령 스프링 부트가 일부 기본적인 자동 보안 구성을 하더라도 원하는 상세한 보안 요구 사항을 만족하려면 오버라이드할 수 밖에 없을 것이다. 

예제 - 시큐리티 스타터

스프링 보안을 구성하는 방법을 약간 바꾸고 싶다. 로그인 페이지를 수정하고 데이터베이스나 LDAP 기반 사용자 저장소를 이용하여 작동하는 인증 서비스를 제공하고 싶다. 

