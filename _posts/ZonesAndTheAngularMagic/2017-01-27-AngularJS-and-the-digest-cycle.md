---
layout: post
title:  "AngularJS 1.x and the digest cycle"
date:   2017-01-27 00:00:00
categories: ZonesAndTheAngularMagic
comments: true
---

AngularJS 1.X로 개발하면 "마술"느낌이 생기고 Angular 2는 여전히 동일한 효과를 준다. 입력에 값을 입력하면 모든 것이 마술처럼 업데이트 된다. <br/>
나는 마술을 좋아하지만, 나는 내가 사용하는 도구로 어떤 일이 벌어지고 있는지 이해하는 것을 선호한다. 당신이 나를 좋아한다면,이 부분이 당신에게도 흥미로울 것이라고 생각한다. 우리는 Angular 2가 어떻게 작동하는지 보게 될 것이다!<br/>
그러나 AngularJS 1.x가 어떻게 작동하는지 먼저 살펴 보도록 하자. AngularJS 1.x는 사용하지 않아도 재미있을 것이다.<br/>
모든 JavaScript 프레임 워크는 대략 동일한 방식으로 작동한다. 개발자는 응용 프로그램 이벤트에 응답하고 응용 프로그램 상태를 업데이트하고 이에 따라 DOM을 새로 고칠 수 있다. 그러나 그들은 모두 그 목표를 달성하는 데 같은 방법을 사용하지는 않는다.<br/>
예를 들어, EmberJS는 개발자에게 setter를 사용하여 개체의 상태를 변경하여 프레임 워크에서 이러한 setter에 대한 호출을 가로 채기를 요청 한다. 이것이 모델에 적용된 변경 사항을 파악하고 이에 따라 DOM을 업데이트 할 수있게 해준다.<br/>
반면, React는 변경 될 때마다 DOM을 다시 계산하기로 하였다. 그러나 전체 DOM을 수정하는 것은 비용이 많이 드는 작업이기 때문에 가상 DOM에 변경 사항을 적용한 다음 가상 DOM과 실제 DOM간에 변경 사항을 적용하기 만하면 된다.<br/>
Angular는 setter를 사용하지 않으며 가상 DOM도 사용하지 않는다. 그러면 DOM에서 무엇을 변경해야하는지 어떻게 알 수 있을까?<br/>
첫 번째 단계는 모델의 변경 사항을 감지하는 것이다. 변경은 사용자가 직접 또는 "시스템" 이벤트 (HTTP 응답, 시간 초과 후 비동기 메서드 실행 등)에서 오는 이벤트에 의해 항상 트리거 된다.<br/>
그렇다면 AngularJS 1.x는 어떤 사건이 발생했는지 어떻게 알 수 있을까? 이 부분은 실제로 매우 간단하다. 예를 들어 ng-click을 클릭 이벤트에 반응 시키거나 ng-model을 사용하여 입력에 대한 변경 사항을 관찰하는 등의 지시문을 사용해야 한다. 또한 서비스를 사용하도록 강요한다. (예 : HTTP 요청의 경우 http http 또는 비동기 적으로 작업을 실행하는 $ timeout).<br/>
이러한 지시문과 서비스를 사용하면 프레임 워크에서 발생한 모든 이벤트에 대한 정보를 얻을 수 있다. 그것은 마술의 첫 번째 부분이다! 그리고 이것은 두 번째 부분을 트리거하는 첫 번째 부분 이다. 프레임 워크는 이제 DOM의 어느 부분을 업데이트 해야 하는지 (및 그 방법) 결정하기 위해 모델에 대한 변경 사항을 분석해야 한다.<br/>
이를 위해 버전 1.x에서 프레임 워크는 관찰자 목록을 유지 관리하며 모델의 특정 부분에서 변경 사항을 관찰하고 이에 대응한다. 단순화 하기 위해 HTML 템플릿에 사용 된 모든 동적 표현식에 대해 관찰자가 만들어진다. 이로 인해 한 페이지에 수백 명의 관찰자가 생길 수 있다.<br/>
이러한 관찰자는 AngularJS 1.x의 핵심이다. 이들은 프레임 워크의 메모리이며 앱의 상태를 기억하기 위해 있다.<br/>
프레임 워크가 이벤트를 감지 할 때마다 (사용자가 ng 모델, HTTP 응답, 시간 초과 실행 등으로 입력에서 무언가를 입력하는 경우) 다이제스트주기를 트리거 한다.<br/>
이 다이제스트주기는 관찰자에 저장된 모든 표현식을 평가하고 새 값과 이전 값을 비교 한다. 변경 사항이 있는 경우 프레임 워크는 DOM을 업데이트해야 한다는 것을 알고 있기 때문에 UI가 이전 값 대신 새 값을 표시한다. 이 기술을 더티 검사라고 한다.<br/>
이 다이제스트주기 동안 Angular는 모든 관찰자 목록을 검토하고 모든 감시 식을 평가한다. 그러나 결과가 안정 될 때까지 즉, 모든 새 값이 이전 값과 같아 질 때까지이 전체주기를 다시 실행 한다.<br/>
왜 그럴까? 감시 된 표현식의 값에서 변경이 감지 될 때마다 콜백 함수가 호출되기 때문에 이 콜백 함수는 모델을 수정하여 하나 또는 여러 개의 다른 감시 식의 값을 변경할 수 있다!<br/>
최소한의 예를 들어 보자. 사용자가 채워야 하는 두 개의 필드 (이름과 비밀번호)가있는 페이지 이다. 페이지에 비밀번호 강도 표시기가 표시된다고 가정 해 보자. watcher는 암호 값을보기 위해 사용되며 변경 될 때마다 강도를 다시 계산한다.<br/>
다이제스트주기의 첫 번째 반복 후 사용자가 비밀번호의 첫 글자를 입력하면 우리는 이 관찰자 목록을 갖게된다.<br/>

```javascript
$$watchers (expression -> value)
- "user.name" -> "Cédric"
- "user.password" -> "h"
- "passwordStrength" -> 0
```

그런 다음 user.password 표현식을 관찰하는 관찰자의 콜백 함수가 호출되고 새 암호 강도가 계산된다.
Angular는 모델에서 수행 된 변경 사항을 알지 못하므로 모델이 안정적인지 알아보기 위해 두 번째 다이제스트 반복을 시작 한다.<br/>

```javascript
$$watchers
- "user.name" -> "Cédric"
- "user.password" -> "h"
- "passwordStrength" -> 3
```

모델이 안정적이지 않는다. 첫 번째 반복 이후 passwordStrength의 값이 변경되었다. 그래서 다른 다이제스트 반복을 시작한다.

```javascript
$$watchers
- "user.name" -> "Cédric"
- "user.password" -> "h"
- "passwordStrength" -> 3
```

이번에는 모델이 안정적이다. AngularJS 1.x가 결과를 DOM에 플러시하는 것은 그 당시 뿐이다. 따라서 다이제스트주기는 응용 프로그램이 변경 될 때마다 최소 2 회 발생 한다. 다이제스트는 최대 10 회까지 반복 할 수 있지만 더 이상 반복하지 않는다. 결과가 안정적이지 않으면 10 회 반복 후 프레임 워크는 무한 루프가 있다고 판단하고 예외를 throw한다.<br/>

그래서 내 작은 드로잉은 훨씬 더 좋아 보인다. 이것은 각 사건 후에 계속되고 있다. 즉, 사용자가 암호 필드에 5자를 입력하면 다이제스트주기가 5 번 실행되며 매번 3 번 반복되므로 총 15 번의 반복이 발생한다.<br/>

실제 응용 프로그램에서는 수백 명의 관찰자가 있을 수 있으므로 모든 이벤트 후에 수천 개의 표현 평가가 가능하다. 최신 브라우저는 매우 빠르며 필요한 경우 몇 가지 사항을 최적화 할 수있는 방법이 있으므로 잘 동작할 것이다. <br/>

AngularJS 1.x에 대한 두 가지 중요한 요점을 다시 정리해 보자.<br/>
• 모델을 변경할 수있는 모든 것에 대해 프레임 워크의 서비스와 지시문을 사용해야 한다.<br/>
• Angular로 처리되지 않는 이벤트가 발생한 후에 모델을 수정하는 것이 가능하지만 (다이제스트주기를 시작하는 유명한 $ scope. $ apply () 메서드를 사용하여) 감지 변경 메커니즘을 명시 적으로 트리거 해야 한ㄷ. 예를 들어 $ http 서비스를 사용하지 않고 HTTP 요청을 보내려면 응답 콜백에서 $ scope. $ apply ()를 호출하여 프레임 워크에 "이봐, 모델에 새 값을 저장 했으니, 다이제스트 사이클을 시작 하겠는가? 

프레임 워크의 마법은 두 부분으로 나눌 수 있다.<br/>
• 각 이벤트가 끝나면 변경 감지를 트리거 한다.<br/>
• 감시자 및 다이제스트주기 덕분에 변경 감지 한다.<br/>
이제 Angular 2가 작동하는 방식과 AngularJS와는 다른 점을 살펴 보자.

