---
layout:     post
title:      "6장 테스트 컨텍스트 프레임워크"
date:       2020-03-10 00:00:00
categories: spring
summary:    6장 테스트 컨텍스트 프레임워크
---

> 토비의 스프링 2권 6장을 요약한 내용 입니다.

# 6.1 테스트 컨텍스트 프레임워크

- 스프링은 테스트에 사용되는 애플리케이션 컨텍스트를 생성하고 관리하고 테스트에 적용해주는 기능을 가진 테스트 프레임워크를 제공한다. 이를 테스트 컨텍스트 프레임워크라고 부른다.
- 자바에서 가장 많이 사용되는 테스트 프레임워크로는 JUnit과 TestNG가 있다.

## 테스트용 애플리케이션 컨텍스트 캐싱과 설정파일

- Junit은 테스트 메소드를 실행할 때마다 매번 테스트 클래스의 새로운 오브젝트를 만든다. 따라서 모든 테스트는 서로 영향을 주지 않으며 독립적으로 실행됨을 보장한다.
- 문제는 테스트가 독립적이라고 해서 매번 스프링 컨텍스트, 즉 컨테이너를 새로 만드는 건 매우 비효율적인 방법이다.
    - 하이버네이트와 같은 ORM은 초기에 엔티티에 대한 정보를 가져와 세션을 지원할 준비 작업을 하고 스레드를 생성하는 등의 많은 부가 작업을 필요로 한다.
- 스프링은 테스트가 사용하는 컨텍스트를 캐싱해서 여러 테스트에서 하나의 컨텍스트를 공유할 수 있는 방법을 제공한다. (713p 그림 6-1 참고)
- 테스트에 테스트 컨텍스트 프레임워크를 적용하려면 테스트 클래스에 두 가지 애노테이션을 부여해줘야 한다.
    - 먼저 @RunWith 애노테이션을 이용해서 JUnit 테스트를 실행하는 러너(Runner)를 스프링이 제공하는 것으로 변경해줘야 한다.
    - 컨텍스트의 설정파일을 지정하여 같은 테스트 클래스안의 테스트 메소드들은 하나의 설정파일로 만들어지는 애플리케이션 컨텍스트를 공유할수 있도록 한다. 
    ( 설정파일 이름을 생략할 경우 현재 클래스 이름에 '-context.xml'이 붙은 파일이 디폴트 설정파일 이름으로 사용된다.

        @RunWith(SpringJUnit4ClassRunner.class)
        @ContextConfiguration("/test-applicationContext")
        public class Test1 {
        	@Test public void testMethod1() { ... }
        	@Test public void testMethod2() { ... }
        }

    ## 컨텍스트 설정의 상속과 컨텍스트 로더

    - 테스트 클래스를 구성할 때 필요하면 상속구조를 활용할 수도 있다.
    - 컨텍스트 파일 정보는 상속되어 서브클래스의 컨텍스트 파일 정보는 슈퍼클래스에서 정의된 것까지 포함된다.

        @ContextConfiguration("common-context.xml")
        public class SuperTest { ... }
        
        @ContextConfiguration("sub-context.xml") // Subtest의 설정 파일은 최종적으로 common-context.xml, sub-context.xml 두 개가 된다. 
        public class SubTest extends SuperTest { ... }

    ## 공유 컨텍스트 사용 시 주의할 점

    - 캐싱 기법을 통해 하나의 컨텍스트를 여러 테스트가 공유할 수 있다는건 분명 테스트 컨텍스트 프레임워크의 장점이다.
    - 하지만 컨텍스트를 공유하는 테스트 메소드는 컨텍스트가 자신이 독점하는 것이 아니므로 그 구성이나 내부 정보를 함부로 변경해서는 안된다.
    - 그럼에도 어쩔 수 없이 컨텍스트의 빈 오브젝트를 조작하고 수정하는 작업이 꼭 필요한 테스트가 있을 수 도 있다.

        @Test
        @DirtiesContext
        public void test() { ... }

    - @DirtiesContext 애노테이션이 붙은 테스트가 수행되고 나면 스프링은 현 테스트 컨텍스트를 강제로 제거한다. (메소드 뿐만 아니라 클래스 레벨에 부여할 수도 있다.)
    - 

    ## DAO 단독 테스트

    - DAO를 개발한 후에 서비스 계층을 거치지 않고 직접 DAO만 테스트해야 할 때가 있다. 문제는 JPA나 하이버네이트 등으로 만든 DAO는 트랜잭션이 시작되지 않은 채로 엔티티 메니저나 세션을 사용하면 예외가 발생한다는 점이다.
    - 그렇다고 DAO 다독 테스트를 하기 위해 서비스 계층을 매번 이용하거나 트랜잭션이 적용된 테스트용 서비스 계층 코드를 만드는 것도 매우 번거롭다.

        @Autowired JpaDao dao;
        
        @Test
        public void query() {
        	List<User> users = dao.findUsers();
        }

    ## 롤백 테스트

    - 롤백테스트란 테스트에서 진행되는 모든 DB 작업을 하나의 트랜잭션으로 묶어서 진행하고, 테스트를 마칠 때 츠랜잭션을 모두 롤백시키는 것이다.
    - 

    ### 트랜잭션 매니저

    - 테스트에서는 TransactionTemplate 과 TransactionCalklback을 이용해 트랜잭션 경계를 설정한 후에 DB를 사용하는 빈을 호출해서 테스트를 진행한다.  테스트 메소드가 끝나고 나면 테스트에서 사용한 dao가 수정한 DB 데이터는 모두 테스트를 실행하기 이전 상태로 복구될 것이다.
    - 

        @Autowird Jpa dao;
        
        @Test
        public void txTest() {
        	new TransactionTemplate(transactionManager).execute(
        		new TransactionCallback<Object>() {
        			public Object doInTransaction(TransactionStatus status) {
        				status.setRollbackOnly();
        
        				dao.deleteAll();
        				dao.add(new Member(10, "Spring", 7.8));
        				assertThat(dao.count(), is(1));
        
        				return null; }});
        }

    ### @Transactional 테스트

    - 테스트의 @Transactional은 강제롤백 옵션이 설정된 트랜잭션으로 만들어진다는 점이다. TransactionStatus의 setRollbackOnly()가 호출되는 것과 동일한 방식으로 동작한다.
    - 트랜잭션이 시작되기 전이나 트랜잭션이 완전히 종료된 후에 해야할 작업이 있을 수도 있다. 이런 경우에는 스프링이 제공한 @beforetransaction과 @AfterTransaction이 붙은 메소드를 사용하면 된다.

    ### ORM 롤백 트랜잭션 테스트의  주의사항

    - ORM은 기본적으로 모든 작업 결과를 바로 DB에 반영하지 않는다. 대신 가능한 한 오랫동안 메모리에 변경사항을 저장하고 있다가 꼭 필요한 시점에서 DB에 반영한다.
    - 최적화를 위한 트랜잭션 내의 캐싱 기법이라고 볼수 있다.
    - ORM의 엔티티 오브젝트를 이용한 작업을 SQL로 만들어 DB로 보내는 작업을 플러스(flush)라고 한다.    - 애스팩트는 그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화해놓은 것이다.
    - 

    ## @Aspect 클래스와 구성요소

    - 애스펙트는 자바 클래스에 @Aspect라는 애노테이션을 붙여서 만든다.
    - @Aspect 클래스는 기본적으로 @Configuration처럼 자바 코드로 만든 메타정보로 활용된다.
    - 특정 클래스를 애스팩트로 사용하려면 먼저 빈으로 등록해야 한다. <bean> 태그를 써도 좋고, @Component를 붙여서 자동스캔 방식으로 등록해도 된다.
    - 포인트컷 : @Pointcut

        // hello에 해당하는 모든 메소드에 적용
        @Pointcut("execution( * hello(..))") 
        private void all() {} 

    - 어드바이스
        - @Before : 메소드 실행 되기 전에 실행
        - @AfterReturning : 타깃 오브젝트의 메소드가 실행을 마친 뒤에 실행
        - @AfterThrowing : 타깃 오브젝트의 메소드에서 예외가 발생하였을 때 실행
        - @After : 메소드 실행이 정상 종료됐을 때와 예외가 발생했을 때
        - @Around : 타깃 오브젝트의 메소드가 호출되는 전 과정을 모두 참여하고 싶을때 사용
    - 포인트컷 표현식은 Vol.1에서 설명했던 execution()을 포함해서 여러 종류의 포인트컷 지시자를 이용해 정의할 수 있다.
    - 하지만 AspectJ AOP와 스프링 AOP의 기술적인 차이점으로 인해 모든 AspectJ 지시자를 가져다 사용할 순 없으며, 경우에 따라서 의미가 조금씩 달라질 수 있다.
    - 스프링에서는 프록시 방식의 AOP를 사용하기 때문에 조인 포인트는 메소드 실행 지점뿐이다. 따라서 포인트컷 설명에서 조인 포인트라고 하면 메소드를 가리킨다고 이해하면 된다.
    - execution() : 접근제한자, 리턴 타입, 타입, 메소드, 파라미터 타입, 예외 타입 조건을 조합해서 메소드 단위까지 선책 가능한 가장 정교한 포인컷을 만들 수 있다.
    - within() : 타입 패턴만을 이용해 조인 포인트 메소드를 선책한다. execution()의 여러 조건 중에서 타입 패턴만을 적용한 것이라고 볼 수 있다.

        @Pointcut(within("com.epril.myproject.dao..*))
        private void daoLayer() {}
        
        @Pointcut(within("com.epril.myproject.service..*))
        private void serviceLayer() {}
        
        @Pointcut(within("com.epril.myproject.web..*))
        private void webLayer() {}

    - this, target : this는 빈 오브젝트의 타입을 확인하고, target은 타깃 오브젝트의 타입과 비교한다.
    - args : 메소드의 파라미터 타입만을 이용해 포인트컷을 설정할 때 사용

    ## @AspectJ를 이용한 AOP의 학습 방법과 적용 전략

    - @AspectJ는 AspectJ AOP의 일부 용어와 개념을 차용한 수준이라 AspectJ AOP보다는 단순하지만 그래도 포인트컷 표현식의 문법과 지시자 사용 방법, 파라미터 선언, 어드바이스 종류와 파라미터 바인딩 방법 등 익혀야 할것이 많다.
    - AOP를 처음부터 모든 개발자가 마음대로 활용하게 하는것보다는 단계를 거쳐 점진적으로 도입하는 것이 중요하다.
    - 객체지향적인 방법으로 해결할 수 있는 것을 불필요하게 AOP를 이용하려고 하지 말아야 한다. ( AOP를 모두 제거해도 핵심기능과 도메인 로직 자체는 이상 없이 동작해야 한다. )
    - AOP도 충분한 테스트를 작성해야 한다.
    - @Aspect 클래스는 스프링의 빈으로 등록되고 DI도 가능하므로 다른 빈과 협력해서 동작할 수 있다.

    # AspectJ와 @Configurable

    ## 5.2.1 AspectJ AOP

    - AspectJ는 기본적으로 자바 언어 자체를 확장해서 만든 aspect 문법을 이용해 애스펙트를 작성해야 한다. 따라서 애프펙트 파일을 위한 별도의 컴파일러가 필요하고 자바 클래스에 애스펙트를 적용하는 데도 별도의 재컴파일 과정이 필요하다.
    - AspectJ에서는 왜 애스펙트 적용을 위해 재컴파일이나 바이트코드 조작 같은것이 필요할까?
        - 스프링 AOP에서는 단지 DI의 도움을 받아 프록시 오브젝트를 추가함으로써 애스펙트를 적용할 수 있었다.
        - 하지만 AspectJ는 이와 달리 아예 타깃 오브젝트 자체의 코드를 바꿈으로써 애스팩트를 적용한다. 따라서 프록시를 사용하지 않고 자바 코드에 처음부터 애스펙트가 적용되어 있던 것처럼 클래스 바이트코드를 변경하는 작업이 필요하다.
        - AspectJ가 이렇게 번거로운 클래스 파일의 바이트코드를 조작을 필요로 하는 이유는 프록시 방식으로는 어드바이스를 적용할 수 없는 조인 포인트와 포인트컷 지시자를 지원하기 위해서다. (99% 정도의 애플리케이션은 메소드 실행 지점을 조인 포인트로 사용해서 충분히 부가기능을 제공할 수 있다. )

    ## 5.2.2 빈이 아닌 오브젝트에 DI 적용하기

    - 도메인 오브젝트는 다른 빈을 참조하지 않는다. 따라서 DI를 받을 필요가 없다. 필요할 때마다 새로운 오브젝트를 만들어야 하니 스프링 컨테이너의 도움을 받아 싱글톤으로 관리할 필요도 없다. 따라서 스프링 빈 등록 대상이 아니다.
    - 그런데 도메인 오브젝트가 다른 빈을 사용하고 싶다면 어떨까?
        - DI를 적용해야 하니 도메인 오브젝트를 스프링 빈으로 등록하고 IOC/DI가 적용되게 해야 한다.
        - 매번 새로운 오브젝트가 필요하니 스코프를 프로토타입으로 선언하고 Provider 등을 이용해 필요할 때마다 새로운 오브젝트를 가져오도록 만들어야 할것이다.
        - 문제는 애플리케이션 코드에서만 도메인 오브젝트를 생성한다면 이런 방식으로는 가능하겠지만 하이버네이트나 iBatis, JPA 등의 프레임워크나 @MVC의 핸들러 어댑터 내부에서 도메인 오브젝트를 생성하는 부분에는 이런 방식의 적용이 불가능하다는 점이다.
        - 그래서 어디서든지 도메인 오브젝트가 생성되면 자동 DI 작업을 수행해주는 어드바이스를 적용해주는 AOP가 필요하다. 이럴 경우에 AspectJ AOP의 도움이 필요하다.

    ### DI 애스펙트

        after(Object bean) returning :
        	beanConstruction(bean) && postConstructionCondition() && inConfigurableBean() {
        		configureBean(bean);
        	}

    - 위의 코드는 @Configurable이 붙은 클래스의 생성자가 호출돼서 오브젝트가 만들어질 때를 가리키는 포인트컷이다.
    - DependencyinjectionAspect 애스펙트가 적용되면 @Configurable이 붙은 도메인 오브젝트가 어디서든 생성될 때마다 이 어드바이스가 적용되어 자동 DI  작업이 일어난다. 또, 빈의 초기화 메소드가 정의되어 있다면 실행된다.

    ### 로드타임 위버와 자바 에이전트

    - DI 애스펙트를 사용하려면 두 가지 작업이 필요하다.
        - AspectJ AOP가 동작할 수 있는 환경 설정
        - DI 애스펙트 자체를 등록해서 @Configurable 오브젝트에 어드바이스 적용
    - AspectJ를 사용하려면 클래스를 로딩하는 시점에 바이트코드 조작이 가능하도록 로드타임 위버를 적용해줘야 한다.
        - 로드타임 위버는 JVM의 javaagent 옵션을 사용해 JVM 레벨에 적용해야 한다.

    # 5.3 로드타임 위버(LTW)

    - 로드타임위버는 단순히 @Configurable을 위해서만 사용되는 건 아니다.
        - @Configurable 지원
        - 트랜잭션  AOP의 모드를 AspectJ로 설정했을 때도 로드타임 위버가 필요하다.
        - JPA는 구현 제품에 따라서 다르긴 하지만 대부분 로드타임 위버를 이용한 바이트코드 조작을 필요로 한다. (독자적인 방식을 사용하는 하이버네이트 JPA를 제외하면 대부분의 JPA 구현 제품은 고급 기능을 위해 로드타임 위버를 사용하도록 요구한다.)

# 5.4 스프링 3.1의 AOP와 LTW

## @EnableAspectJAutoProxy

- @EnableAspectJAutoProxy는 @Aspect로 애스팩트를 정의할 수 있게 해주는 @AspectJ AOP 컨테이너 인프라 빈을 등록해준다.

    @Aspect
    public class MyAspect {
    	...
    }

    @Configuration
    @EnableAspectJAutoProxy
    public class AppConfig {
    	@Bean MyAspect myAspect() {
    		return new MyAspect();
    	}
    	...
    }

- 자바 코드를 이용해 MyAspect가 애스팩트로 동작하게 하려면 다음과 같이 @Configuration 클래스에 @EnableAspectJAutoProxy를 붙여주고 MyAspect를 빈으로 등록해주면 된다.

## @EnableLoadTimeWeaving

- @EnableLoadTimeWeaving은 환경에 맞는 로드타임 위버를 등록해주는 어노테이션이다.

    @Configuration
    @EnableLoadTimeWeaving
    public class Appconfig {
    	...
    }된다.** 관람객이 스스로 가방 안의 현금과 초대장을 처리하고 판매원이 스스로 매표소의 티켓과 판매 요금을 다루게 한다면 이 모든 문제를 한 번에 해결할 수 있을 것이다. 

## 자율성을 높이자

Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨기는 것이다. TicketSeller에 sellTo 메서드를 추가하고 Thater에 있던 로직을 이 메서드로 옮기자

    public class TheaterSeller {
    	private TicketOffice ticketOffice;
    
    	public Theater(TicketOffice ticketOffice) {
    		this.ticketOffice = ticketOffice;
    	}
    
    	public void sellTo(Audience audience) {
    		if(audience.getBag().hasInvitation()) {
    			Ticket ticket = ticketOffice.getTicket();
    			audience.getBag().getTicket(ticket);
    		} else {
    			Ticket ticket = ticketOffice.getTicket();
    			audience.getBag().minusAmount(ticket.getFee());
    			ticketOffice.plusAmount(ticket.getFee());
    			audience.getBag().setTicket(ticket);
    		}
    	}
    }

    public class Theater {
    	private TicketSeller ticketSeller;
    
    	public Theater(TicketSeller ticketSeller) {
    		this.ticketSeller = ticketSeller;
    	}
    
    	public void enter(Audience audience) {
    		ticketSeller.sellTo(audience);
    	}
    }

이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 **캡슐화**라고 부른다. 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다. 

Theater는 오직 TicketSeller의 인터페이스에만 의존한다. TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현의 영역에 속한다. 

TicketSeller 다음으로 Audience의 캡슐화를 개선하자

    public class Audience {
    	private Bag bag;
    
    	public Audience(Bag bag) {
    		this.bag = bag;
    	}
    
    	public Long buy(Ticket ticket) {
    		if(bag.hasInvitation()) {
    			bag.getTicket(ticket);
    			return 0;
    		} else { 
    			bag.minusAmount(ticket.getFee());
    			bag.setTicket(ticket);
    			return ticket.getFee();
    		}
    	}
    }

    public class TheaterSeller {
    	private TicketOffice ticketOffice;
    
    	public Theater(TicketOffice ticketOffice) {
    		this.ticketOffice = ticketOffice;
    	}
    
    	public void sellTo(Audience audience) {
    		iticketOffice.plusAmount(audience.buy(ticket.getFee()));
    	}
    }

수정된 Audience와 TicketSeller는 자신이 가지고 있는 소지품을 스스로 관리한다. 따라서 코드를 읽는 사람과의 의사소통이라는 관점에서 이 코드는 확실히 개선된 것으로 보인다. 더 중요한 점은 Audience나 TicketSeller의 내부 구현을 변경하더라도 Theater를 함께 변경할 필요가 없어졌다는 것이다. 따라서 수정된 코드는 변경 용이성의 측면에서도 확실히 개선됐다고 말할 수 있다. 

## 어떻게 한 것인가

**자기 자신의 문제를 스스로 해결하도록 코드를 변경한 것이다.** 우리는 우리의 직관을 따랐고 그 결과로 코드는 변경이 용이하고 이해 가능하도록 수정됐다. 

## 캡슐화와 응집도

핵심은 객체 내부의 상태를 **캡슐화**하고 객체 간에 오직 **메시지**를 통해서만 상호작용 하도록 만드는 것이다. 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다. 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 **결합도를 낮출 수 있을 뿐더러 응집도를 높일 수 있다.** 

**외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길인 것이다.** 

## 절차지향과 객체지향

변경 전 초기 코드를 다시 살펴보자

Theater의 enter 메서드는 **프로세스(Process)**이며 Audience, TicketSeller, Bag, TicketOffice는 **데이터(Data)**이다. 이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 부른다. 

절차적 프로그래밍은 코드를 읽는 사람과 원활하게 의사소통하지 못한다. 더 큰 문제는 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다

**변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다.** 

해결 방법은 자신의 데이터를 스스로 처리하도록 프로세스의 적절한 단계를 Audience와 TicketSeller로 이동시키는 것이다. 이처럼 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍이라고 부른다. 

**훌륭한 객제치향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.** 

## 책임의 이동

당신의 코드에서 데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치하고 있다면 절차적 프로그래밍 방식을 따르고 있을 확률이 높다. 데이터와 데이터를 사용하는 프로세스가 동일한 객체 안에 위치한다면 객체 객체지향 프로그래밍 방식을 따르고 있을 확률이 높다. 

설계를 어렵게 만드는 것은 의존성 이라는 것을 기억하라. **해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다.** 

## 더 개선할 수 있다

Audience는 스스로 티켓을 구매하고 가방안의 내용물을 직접 관리한다. 하지만 Bag은 과거의 Audience처럼 스스로 자기 자신을 책임지지 않고 Audience에 의해 끌려다니는 수동적인 존재다. 

Bag을 자율적인 존재로 바꿔보자

    public class Bag {
    	private Long amount;
    	private Ticket ticket;
    	private Invitation invitation;
    
    	public Long hold(Ticket ticket) {
    		if(hasInvitation()) {
    			setTicket(ticket);
    			return 0;
    		} else {
    			setTicket(ticket);
    			minusAmount(ticket.getFee());
    			return ticket.getFee();
    		}
    	}
    
     ...
    }

    public class Audience {
    	public Long buy(Ticket ticket) {
    		return bag.hold(ticket);
    	}
    }

TicketSeller 역시 TicketOffice의 자율권을 침해하였다

    public class TicketOffice {
    	public void sellTicketTo(Audience audience) {
    		plusAmount(audience.buy(getTicket()));
    	}
    	...
    }

    public class TicketSeller {
    	public void sellTo(Audience audience) {
    		ticketOffice.sellTicketTo(audience));
    	}
    }

## 객제치향 설계

### 설계가 왜 필요한가

설계란 코드를 배치하는 것이다. **설계를 구현과 떨어트려서 이야기하는 것은 불가능하다.** 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다. 설계는 코드 작성의 일부이며 코드를 작성하지 않고서는 검증할 수 없다. 

### 그렇다면 좋은 설계란 무엇인가?

**좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다**

개발을 시작하는 시점에 구현에 필요한 모든 요구사항을 수집하는 것은 불가능에 가깝다. 모든 요구사항을 수집할 수 있다고 가정하더라도 개발이 진행되는 동안 요구사항은 바뀔 수밖에 없다. 

> 요구사항 변경은 필연적으로 코드 수정을 초래하고, 코드 수정은 버그가 발생할 가능성을 높인다. 코드 수정을 회피하려는 가장 큰 원인은 **두려움**이다. 그리고 그 두려움은 요구사항 변경으로 인해 버그를 추가할지도 모른다는 **불확실성**에 기인한다.

### 객체지향 설계

객제치향 프로그래밍은 **의존성**을 효율적으로 통제할 수 있는 다양한 방법을 제공함으로써 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높여준다. 단순히 데이터와 프로세스를 객체라는 덩어리 안으로 밀어 넣었다고 해서 변경하기 쉬운 설계를 얻을 수 있는 것은 아니다.