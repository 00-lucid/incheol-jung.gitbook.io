---
description: Functional Programming in Java 8의 Chapter 1을 요약한 내용 입니다.
---

# Chap 01. 헬로, 람다 표현식

## 사고의 전환

명령형 스타일 방식은 초창기 자바에서 제공하는 방식이다. 이러한 스타일은 개발하려고 하는 작업의 모든 과정을 직접 자바 코드로 작성해야 하며 각 과정이 제대로 실행되는지 매번 확인해야 한다.

자바에서는 특정 작업에 대해 프로그래밍하기 위해서는 어떻게 해야 한다는 것을 자세히 설명하기보다는 원하는 것은 바로 이것이다라고 명확하게 도와주는 방법들이 있다.

### 습관적 방법

주어진 cities라는 컬렉션에서 Chicago라는 도시 이름이 있는지 검색하는 예제를 살펴보자.

```java
boolean found = false;
for(String city : cities) {
	if(city.equals("Chicago")) {
		found = true;
		break;
	}
}

System.out.println("Found chicago?:" + found);
```

### 더 나은 방법

관찰력이 좋은 자바 개발자라면, 위의 코드를 보자마자 좀 더 이해하기 쉽고 간결한 코드로 바꾸려고 할 것이다. 다음의 코드를 살펴보자

```java
System.out.println("Found chicago?:" + cities.contains("Chicago"));
```

### 개선된 부분

* 난잡한 가변 변수\(Mutable Variable\)의 사용을 방지
* 어수선한 코드의 사용을 맏아줌
* 코드에 대한 설명이 명확해짐 : 개발자가 원하는 바를 유지할 수 있음
* 비즈니스 의도는 유지하면서 코드는 명료해짐
* 오류의 발생 확률을 줄여줌
* 이해하기 쉽고 유지 보수가 쉬움

### 기존 방법

price의 합을 구하는데 $20보다 전체 private가 높으면 10% 할인한다고 가정하자

```java
BigDecimal totalOfDiscountedPrices = BigDecimal.ZERO;

for(BigDecimal price : prices) {
  if(price.compareTo(BigDecimal.valueOf(20)) > 0) 
    totalOfDiscountedPrices = 
      totalOfDiscountedPrices.add(price.multiply(BigDecimal.valueOf(0.9)));
}

System.out.println("Total of discounted prices: " + totalOfDiscountedPrices);
```

위의 코드를 실행해보면 동작하는 데는 문제가 없다. 단지 이러한 코드는 개발자가 원하는 내용을 무조건 코드로 작성해야 한다는 "원시적인 강박관념"에 사로 잡혀 있는 것처럼 보이며, 단일 책임 워칙을 무시한다.

### 다시, 더 나은 방법

자바에서 가변 변수를 생성하고 그 변수를 반복해서 값을 할당하기보다는 좀 더 고차원적인 추상화 방법을 사용해보자.

```java
final BigDecimal totalOfDiscountedPrices = 
  prices.stream()
        .filter(price -> price.compareTo(BigDecimal.valueOf(20)) > 0)
        .map(price -> price.multiply(BigDecimal.valueOf(0.9)))
        .reduce(BigDecimal.ZERO, BigDecimal::add);

System.out.println("Total of discounted prices: " + totalOfDiscountedPrices);
```

코드는 간결해 보이지만 사실 이 코드 안에는 자바8에서 등장한 몇 가지 새로운 기능들을 사용하고 있다.

* prices 리스트에서 stream\(\) 메서드를 호출했다.
* prices 리스트를 이터레이션하는 대신 특별한 메서드인 filter\(\)와 map\(\)을 사용한다.
* reduce\(\) 메서드를 호출하여 map\(\) 메서드의 결과로 얻은 전체 합계를 계산한다.

### 향상된 점

* 코드가 어수선하지 않고 더 짜임새 있게 구성됐다
* 로우-레벨 오퍼레이션을 사용하지 않는다.
* 로직을 강화하거나 변경하기에 더 쉽다.
* 메서드를 사용할 때 이터페이션은 라이브러리에 의해 제어된다.
* 더 효율적이다. 루프에 대한 lazy evaluation이 가능하다.
* 원하는 부분을 병렬화하기가 더 쉽다.

### 난관 극복의 핵심, 람다

명령형 프로그래밍의 번거로움을 해결하는 함수형 프로그래밍 방법의 중요한 기능중 하나가 람다이다. 자바에서 새롭게 제공되는 기능을 사용해서 기존의 프로그래밍 방법을 변경하면 더욱 세련되고 간결한 코드를 만들 수 있을 뿐만 아니라 오류가 줄어들고, 더 효율적이고 더욱 쉽게 최적화, 성능 향상, 그리고 병렬화가 가능하다.

## 함수형 스타일 코드의 큰 이점

함수형 스타일 코드는 투자 대비 높은 효율의 코드를 만든다.

* 변수의 명시적인 변경이나 재할당의 문제를 피할 수 있다.
* 함수형 버전은 쉽게 병렬화가 가능하다.
* 서술적인 코드 작성이 가능하다
* 함수형 버전은 더 간결하다
* 함수형 스타일 버전은 직관적이다.
* 함수형 스타일과 OOP 스타일을 효과적으로 혼합하여 사용할 수 있다.

> 간결하다는 것이 코드가 적다는 것을 의미하는가?

간결하다는 것은 코드가 명확하고, 오류가 없고 결국 개발자의 의도를 효과적으로 전달한다는 것이다. 간결한 코드는 군더더기가 없다. 이것은 설계 아이디어를 빠르게 적용해보고 더 좋은 쪽으로 변경하거나 쉽게 수정할 수 있다는 것을 의미한다.

## 함수형 스타일로 코딩해야 하는 이유

### 문제의 핵심은 이터레이션

* 객체의 리스트를 처리하기 위해 매번 반복문을 작성했고 sets와 map을 사용했다.
* 컬렉션에 있는 각 엘리먼트를 어떻게 반복하고 출력할까? → for 루프를 사용했다.
* 컬렉션에서 어떻게 엘리먼트를 선택할까? → for 루프를 사용했다.

#### 자바는 다양한 오퍼레이션을 위해 다양한 내부 이터레이터를 제공한다.

* 단순 엘리먼트 검색 루프
* 데이터 값 매핑 루프
* 필터링 루프
* 최종값 연산

### 정책 확장하기

정책은 직접적으로 강화하는 것 이상으로 점점 발전해 나간다. 확장성의 기본 구조는 하나 이상의 인터페이스로 되어 있다는 점이다. 이러한 인터페이스와 그 인터페이스를 구현하는 클래스의 계층 구조를 주의 깊게 설계해야 한다. 이렇게 설계를 한 결과는 효과적일 수 있으나, 그만큼의 노력을 들여서 탄생한 인터페이스와 클래스들은 유지 보수를 위한 노력이 또 들어간다.

#### 다른 방법이 있다.

함수형 인터페이스와 람다 표현식을 사용하는 방법이다. 이 방법은 추가적인 인터페이스나 메서드 이름을 따를 필요는 없지만 대신에 제공하려는 코드의 Behavior에 집중해야 한다.

### 손쉬운 병렬화

개발팀은 순차 구조로 되어 있는 거대한 모듈들의 코드를 동시에 실행할 수 있는 버전으로 바꾸는 것이 상당한 노력이 들고, 복잡도를 증가시키며 멀티 스레딩과 관련된 버그를 만들어낼 수 있다는 것을 알았다.

* 성능을 올릴 수 있는 좀 더 쉬운 방법이 없을까?
* 순차 방식과 병렬 방식의 코드 사이에 차이점이 없다면 순차적으로 실행하는 것과 병렬로 실행하는 것이 의도한대로 명확하게 스위치될 수는 없을까?

### 스토리텔링

비즈니스가 요구하는 바와 이를 코드로 구현하는 데에서 오는 차이로 많은 것들이 사라지고 왜곡된다. 이 둘 사이의 차이가 크면 클수록, 오류가 발생할 확률도 증가하며 유지 보수에 들어가는 비용도 증가한다. 비즈니스 측면에서 문제를 설명하는 방식대로 코드를 설명할 수 있다면, 더 쉽게 이해할 수 있고 더 쉽게 비즈니스 관련직 사람들과 논의할 수 있으며 그들의 요구사항을 더 쉽게 만족시킬 수 있다. 8장 '람다표현식의 조합'을 참고하자

### 문제의 분리

애플리케이션에서 공통적으로 필요한 것은 코어 연산과 연산에 필요한 세밀한 로직을 분리하는 것이다. \(ex. 주문 - 세금 연산\)

OOP에서는 이러한 방식을 문제의 분리\(Seperation of Concern\)라고 하며 스트레트지 패턴\(Strategy Pattern\)을 사용하여 해결한다.

이보다 훨씬 적은 코드로 구현할 수 있다. 코드 구조 속에서 헤매지 않고 설계 아이디어를 구체화할 수 있다. 문제를 분리하는 방법은 4장 '람다를 사용한 문제의 분리'를 참고하자

### 이밸류에이션의 지연

엔터프라이즈 애플리케이션을 생성할 때, 웹 서비스와 상호 연동해야 하고 데이터베이스 호출을 생성하고 XML을 처리하는 등의 작업을 해야 한다. 해야 할 작업이 너무 많지만 그것들 모두가 동시에 필요한 것은 아니다. 몇 개의 오퍼레이션을 피하거나 적어도 잠시 실행을 연기시키는 것은 성능을 향상시킬 수 있는 가장 쉬운 방법이다.

간단한 목표지만 순수한 OOP 방법만으로는 구현하기가 꽤 어렵다. 반대로 새로운 Optional 클래스와 함수형 스타일의 API를 사용하여 노력을 최소화하고 원하는 것을 더욱 명확하게 할 수 있다. 6장의 '지연 초기화'를 참고하자

### 테스트성 향상시키기

변경이 덜한 코드가 오류를 발생시키는 일도 드물다. 본질적으로 함수형 스타일 코드는 변화에 유연하며 상대적으로 테스트 노력이 덜하다.

이는 4장 '람다 표현식을 이용한 설계'와 5장 '리소스를 사용한 작업'에서 상당한 수준의 예외 처리 테스트를 만드는 데 도움을 준다. 람다 표현식은 또한 테스트 목적으로도 사용된다.

## 혁명이 아닌 진화

함수형 스타일의 이점을 얻기 위해 다른 언어로 바꿀 필요는 없다. 자바 언어 팀은 언어와 JDK에 함수형 기능을 넣기 위해 많은 시간과 노력을 쏟아왔다. 몇 개의 가이드라인을 따르면 우리의 코드를 향상시킬 수 있다.

### 서술적

불변 컬렉션에서 containts\(\) 메서드를 서술적으로 사용하는 것이 명령적 스타일을 사용하는 경우보다 코드를 작성하는 면에서 얼마나 쉬운지 알아봤다. 이터페이션을 제어하는 것과 같은 노력이 많이 들고 주의 깊게 작성해야 하는 코드와 로우 레벨의 코드들은 라이브러리의 함수들을 사용하여 처리하도록 하고 그 세부적인 코드까지는 신경 쓸 필요가 없다.

불변성과 서술적 프로그래밍은 함수형 프로그래밍 스타일의 원천 기술이며 이제 자바에서 이러한 기능들을 사용할 수 있게 됐다.

### 불변성의 증진

가변 데이터는 수정하면 할수록 컴포넌트들이 실행을 멈추거나 오류가 발생할 가능성이 더 커진다. 또한 이해하기 어렵고 병렬화하기가 상당히 까다롭다. 가변성을 피하기 위해서 순수 함수를 생성할 수도 있다.

### 사이드 이펙트의 회피

사이드 이펙트가 없는 함수는 불변이며 함수를 사용하는 중에 함수에 대한 입력의 변경이 없다. 이 함수들은 이해하기가 쉽고 오류의 발생 가능성이 낮으며 더 쉽게 최적화할 수 있다. 사이드 이펙트가 없다면 레이스 컨디션의 문제나 동기화 업데이트 문제를 해결해준다.

### 단순 문법보다는 표현에 주력

문법적인 문장은 이해하기 어렵고 가변성 문제를 일으킨다. 서술문을 사용하면 가변성이 줄어들고 함수들을 혼합하여 사용할 수 있다. 간결한 버전을 사용하면 해결해야 할 문제가 변경됐을 때 코드를 수정하기 쉽다.

### 고차 함수를 사용한 설계

불변성을 강요하는 하스켈과 같은 함수형 프로그래밍 언어와는 달리 자바는 변수를 개발자의 의지대로 수정할 수 있다. 그래서 자바는 완전한 함수형 프로그래밍 언어는 아니다. 그러나 고차 함수를 사용하여 자바에서 함수형 스타일로 코드를 작성할 수 있다. 고차 함수는 현재 상태가 아닌 이후의 상태에서도 현재 사용하는 함수를 재사용할 수 있도록 해주는 개념이다.

고차 함수를 사용하면 다음과 같은 일들을 할 수 있다.

* 함수를 파라미터로 함수에게 전달한다.
* 함수 내부에서 함수를 생성한다.
* 함수로부터 함수를 리턴한다.

### 정리

이제 많은 기능을 갖는 함수형 스타일과 고차 함수를 사용하여 프로그램을 작성할 수 있다 .이것은 오류가 거의 없는 코딩이 가능하며 또한 이해하기 쉽고, 유지 보수 및 병렬화하기 쉽도록 해준다. 자바 컴파일러는 마치 마법과도 같이 함수형 인터페이스가 원하는 곳으로 람다 표현식이나 메서드 레퍼런스를 보낼 수 있게 해준다.

