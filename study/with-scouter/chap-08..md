---
description: '자바 트러블슈팅: scouter를 활용한 시스템 장애 진단 및 해결 노하우를 챕터 8을 요약한 내용입니다.'
---

# CHAP 08. 스레드 때문에\(스레드에서\) 발생하는 문제들

대부분의 프로그래밍 언어들처럼 자바도 기본적으로 하나의 프로세스로 수행되고, 그 내부적으로 여러 개의 스레드가 동작하는 구조로 이루어져 있다. 하나의 CPU 코어의 성능을 향상시키는 것은 한계에 다다랐기 때문에, 코어 개수를 증가시키는 추세다. 다시 말하면, 자바 기반으로 어떤 애플리케이션을 개발하든지 단일 스레드에서 처리할 수 있는 속도는 한계가 있으므로 여러 스레드에서 처리할 수 있는 방법을 반드시 알고 있어야만 한다.

어떻게 보면, 모든 장애의 원인은 스레드에서 수행되는 프로그램에서 발생한다.

## WAS의 적절한 스레드 개수는 몇 개일까?

스레드 풀 설정에 대해 물어오면 필자는 최대 스레드 개수를 1,000 ~ 2,000개 정도 잡으라고 한다. 물론, 문제의 원인이 스레드 개수가 아니라면, 스레드 풀을 어떻게 설정하더라도 죽을 서버는 죽는다.

### 그렇다면 가장 적절한 개수는 몇 개나 될까?

그 개수에 대한 절댓값은 없다. 하지만 해당 서버에서의 가장 적절한 개수는 다음과 같이 계산할 수 있다. A라는 시스템의 가장 많이 사용하는 상위 80%에 해당하는 URL을 추출하여 성능 테스트를 수행한다. 테스트를 수행한 결과 50명의 가상 사용자가 최대 처리할 수 있는 사용자로 나왔고 이때의 최대 초당 처리량은 200건이다.

#### 그렇다면 스레드 풀에 최소한 몇 개의 스레드를 지정하여 사용하는 것이 적절할까?

1. 80개
2. 50개
3. 200개

정답은 이 장 마무리에 공개하겠다.

## 스레드에서 발생하는 문제 중 가장 대표적인 것은?

스레드에서 일어나는 문제점 중 가장 대표적인 것이 잠김\(Lock\)이 발생하는 것이다. 공유되는 데이터를 처리하기 위해서 잠시 록을 거는 것은 문제가 되지 않는다. 하지만 록이 풀리지 않거나, 그 록이 풀리기만을 여러 스레드에서 대기하고 있다면 성능상 문제뿐만이 아니라 서비스가 제대로 동작하지 않을 수도 있다. 치명적인 경우에는 서버에 행\(hang\)이 걸려 아무런 응답을 하지 않기도 한다. 자바 관련 서적 중\(High0Performance Java Platform Computing\)이라는 책의 3장에는 스레드를 처리함에 있어서 대표적인 문제가 다음과 같이 분류되어 있다.

* 레이스 컨디션\(race condition\)
* 데드락\(deadlock\)
* 스타베이션\(starvation\)
* 라이브 록\(live lock\)
* 다른 형태의 예측 불가능한 오류\(nondeterminism\)

### 레이스 컨디션

멀티 스레드 환경에서 공유 데이터에 대해 아무런 록 처리를 하지 않을 경우, 동시에 스레드가 처리하러 들어왔을 때 데이터가 꼬여서 무한 대기하거나 무한 루프에 빠질 수도 있다. 이러한 경우를 레이스 컨디션이라고 한다.

이러한 문제를 해결하기 위해서 스레드의 우선순위를 지정할 수 있지만 대부분 이 값을 변경하지는 않는다.

### 데드록

데이터를 안전하게 처리하기 위해서 거는 록에서 문제가 발생할 수도 있다. 두 개 이상의 스레드에서 이 록이 서로 풀리기만을 기다리는 상황이 발생할 수 있는데, 이러한 상황을 데드록이라고 한다.

> * 스레드 1이 DataA에 록을 건 상태에서 DataB에 접근하려고 한다.

* 스레드 2가 DataB에 록을 건 상태에서 DataA에 접근하려고 한다.

이 처럼 타이밍이 딱 맞아 떨어져서 두 스레드가 동시에 요청되어 서로 물고 물리는 상황이 되고, 둘 다 대기하고 있는 상태를 데드록이라고 한다.

```text
public class Deadlock {
    static class Friend {
        private final String name;
        public Friend(String name) {
            this.name = name;
        }
        public String getName() {
            return this.name;
        }
        public synchronized void bow(Friend bower) {
            System.out.format("%s: %s"
                + "  has bowed to me!%n", 
                this.name, bower.getName());
            bower.bowBack(this);
        }
        public synchronized void bowBack(Friend bower) {
            System.out.format("%s: %s"
                + " has bowed back to me!%n",
                this.name, bower.getName());
        }
    }

    public static void main(String[] args) {
        final Friend alphonse =
            new Friend("Alphonse");
        final Friend gaston =
            new Friend("Gaston");
        new Thread(new Runnable() {
            public void run() { alphonse.bow(gaston); }
        }).start();
        new Thread(new Runnable() {
            public void run() { gaston.bow(alphonse); }
        }).start();
    }
}

// result
// Alphonse: Gaston has bowed to me!
// Gaston: Alphonse has bowed to me!
```

### 스타베이션

스타베이션은 어떻게 보면 데드록과 비슷하다. 하지만 그 원인은 데드록과는 다르다. 스타베이션은 멈추어 있는 스레드가 이론적으로 수행은 할 수 있지만 CPU로부터 일할 기회를 받지 못하는 경우 때문에 발생한다. 그 원인은 우리나라 청년 실업이 몇만시대인 이유와 비슷하다. 일하려는 의지도 있고 필요한 지식들도 갖고 있지만, 그 기회가 주어지지 않기 때문이다.

### 라이브 록

하나의 스레드에서 다른 스레드로 응답을 주는 경우가 있다. 그런데 응답을 받은 스레드에서 요청했던 그레드로 다시 요청을 하는 작업이 계속 반복될 수 있는데, 이것을 라이브 록이라고 한다. 라이브 록과 데드록의 차이는 데드록의 경우 CPU를 점유하지 않고 멈추어버리지만, 라이브 록은 멈추지 않고 지속해서 수행하므로 CPU까지 점유할 확률이 높다. 그렇게 되면 CPU 코어 하나를 모두 점유해 버릴 수 있으니 CPU 사용량도 같이 모니터링하는 것을 권장한다.

### 다른 형태의 예측 불가능한 오류

앞의 레이스 컨디션은 예측 불가능한 오류의 일종이다. 그런데 레이스 컨디션 말고도 예측 불가능한 오류가 존재한다. 예를 들면, 별도로 수행되는 멀티 스레드 프로그램이 있는데, 그 결과는 항상 같다고 생각했지만, 경우에 따라서 그 결과가 달라지는 경우가 여기에 속한다. 보통 트랜잭션을 처리하는 부분에서 이러한 상황이 발생한다.

## 록 경합을 피라는 10 + 1가지 방법

### 코드가 아닌 데이터를 보호하라\(Protext data, not code\)

스레드에 안전한 코드를 위해서 전체 함수 호출을 큰 록으로 감싸는 것이다. 자바에서는 메서드를 synchronized로 선언하는 것이 그 예다. 하지만 동시에 여러 스레드에서 접근하는 것을 막을 대상은 데이터지 코드가 아니다. 따라서, 데이터만 synchronized 블록으로 감싼다면 중요한 코드를 잠그는 데 수행하는 시간을 줄일 수 있다.

### 록 사용 부분에서는 비싼 계산을 하지 말아라

재정렬 작업을 짧게 하고 임시 변수를 사용하는 등의 작업으로 로게서 소요하는 시간을 줄일 수 있다. 특히 I/O와 관련된 작업이라면 효과가 더 크다.

### 록을 분리해라

배열 전체가 동일한 록으로 보호 받지 않고, 배열 각가의 요소에 따로 록을 걸 수 있다면 배열 요소들이 서로 다른 록을 갖도록 분산하고, 스레드 간의 동일한 록을 얻기 위해서 결쟁하지 않도록 만드는 것이 좋다. 조금 더 일반적인 조언을 덧붙이자면, 서로 다른 데이터에는 서로 다른 록을 사용하라는 것이다.

### 내부적인 록이나 atomic 작업을 사용하라

대부분의 병렬 프로그램 시스템은 단순한 작업을 수행할 수 있도록 atomic 연산을 제공한다.

### 동기화된 데이터 구조를 사용하라

만약 atomic 연산을 직접 사용할 수 없다면, 내부적으로 atomic을 사용하는 데이터 구조를 사용할 수 있다. lock-free 메시지 큐가 그 예다.

### 가능하다면 읽기-쓰기 록 디자인 패턴을 사용하라

많은 읽기 작업만 수행하는 사용자들은 동시에 처리할 수 있고, 쓰기 위한 사용자는 록을 걸어서 처리하는 읽기와 쓰기 록\(reader-writer lock\)을 사용할 수 있다 .

### 가능하다면 읽기 전용 데이터를 사용하라

자바를 포함한 몇몇 동시 처리 프로그래밍 시스템은 록을 걸지 않고도 모든 스레드에서 접근할 수 있는 읽기 전용 데이터를 만들 수 있다.\(단, 그 데이터가 전혀 변경되지 않는다는 조건을 만족해야만 한다\)

### 객체 풀링을 피해라

이전에는 객체를 생성하는 비용이 매우 비싸서 여러 스레드가 재사용하기 위해 생성된 객체를 풀\(pool\)에 저장해두었다. 하지만 동시에 여러 스레드가 풀에 접근할 경우에는 데이터 보호 때문에 다중 스레드에서는 문제가 된다. 그러니 객체를 생성하여 풀에다 저장하는 일은 피하는 편이 좋다.

### 지역 변수를 사용하거나 스레드 로컬 저장소를 사용하라

많은 경우에 각각의 스레드의 로컬에 있는 공유 변수는 다른 것으로 치환할 수 있다. 이렇게 했을 때 데이터를 처리하는 비용이 감소되는 간단한 경우를 생각해 보자. 먼저, 배열에 있는 가장 큰 수를 찾을 때를 예로 들어보자. 많은 스레드에서 값이 증가될 때마다 최갯값을 따로 저장해 놓는다면, 매번 최댓값을 찾기 위해서 데이터를 검색하는 비용을 줄일 수 있을 것이다. 아니면, 각 스레드 저장소에 결괏값을 따로 갖고 있다가, 필요할 때에만 마지막에 그 결과를 취합할 수도 있다. \(동시 접근이 적은 경우에 적합\)

### 핫스폿을 피하라\(Avoid hotsopts\)

핫스폿은 매우 잦은 변경이 일어나는 리소스 중 하나다. 많은 리스트 구현체에 리스트의 크기는 어딘가에 저장되어 있다. 그렇게 하지 않는다면 size\(\) 메서드를 호출할 때마다 일일이 데이터의 크기를 확인해 봐야 하기 때문에, 데이터의 크기만큼 시간이 소요될 것이다. 그렇다면 다중 스레드 상황에서는 어떤 것이 더 좋은 성능을 낼 것인지 생각해 보자. 각각의 리스트의 요소 개수가 변경될 때마다 크기를 저장하는 변수를 수정해야 하고, 그 작업을 수행하는 메서드는 동시 접근을 처리하기 위해서 보호되어야만 한다. 이것을 핫스폿이라고 한다. 이 경우에 이러한 문제를 해결하는 가장 쉬운 방법은 목록의 크기를 저장하지 않는 것이다. 하지만 리스트의 크기를 확인하는 시간은 데이터의 개수가 많을수록 증가할 것이다. 소프트웨어 개발은 가장 적합한 트레이드오프를 찾는 작업이다.

### 트랜잭션을 제공하는 메모리 시스템을 사용하라

트랜잭션을 처리하는 메모리는 록을 처리하기 위해 복잡한 부분을 없애 주기 때문에 매우 정제된 록의 모든 장점을 여러분에게 제공할 것이다. 하지만 불행하게도 실제 운영 상황에서 적용할 수 있는 트랜잭션 처리가 가능하 메모리를 보지 못했다.

## 끝나지 않는 루프

만약 CPU코어가 네 개인 장비에서 하나의 무한 루프가 발생하면, 전체 CPU 사용량은 25%로 나타나더라도 하나의 CPU가 100%를 지속해서 점유할 확률이 높다. 그 외에도 무한루프는 XML 파싱하는 부분의 라이브러리 오류와 정규 표현식을 잘못 써서 발생하는 경우도 있다. 그런데 최악의 상황은 무한 루프를 수행하면서 객체의 크기가 지속해서 커지는 경우다. 그럴 경우에는 CPU만 점우하는 것이 아니라 메모리까지 점유하게 되므로 결국에는 OutOfMemoryError가 발생하고 말 것이다.

## 스레드 개수 문제에 대한 권장안

50은 여기서 최대 처리 가능한 가상 사용자 수를 말한다. 60명의 가상 사용자만큼 부하를 준다고 해도 해당 시스템은 동시에 처리할 수 있는 스레드 개수는 50개라 10명에 해당하는 스레드는 어딘가에 대기하고 있을 것이다.

### 초당 200건을 처리하는 것은 어떻게 가능할까?

이말은 50명의 가상 사용자의 평균 응답 속도가 0.25초라는 말이 된다. 한 명의 가상 사용자가 0.25초를 소요하니 , 1초에 네 번 수행할 수 있다. 따라서 스레드를 200개까지 지정할 필요도 없다. 결론적으로 해당 시스템에 가장 적절한 최소 스레드 개수는 50개가 된다. 하지만 우리는 상위 80%의 대상에 대해서 테스트를 했다. 추가적인 병목에 사용자들의 요청이 묶일 수도 있다. 그러므로 50개 + 20~40%로 계산하면 해당 시스템에서는 60~70개 정도가 적당하다고 볼 수 있다.

필자의 말이 미심쩍다면 스레드 풀의 최대 개수를 1,000개로 설정해라. 그래도 죽을 서버는 죽는다. 하지만 스레드 개수가 증가하면 증가할수록 스레드에서 점유하는 기본 메모리로 인해 애플리케이션에서 가용한 메모리는 점점 줄어든다는 것을 반드시 알아야만 한다.

참고로 Tomcat과 같은 WAS의 경우 초기 스레드 개수와 최대 스레드 개수를 정한다고 하더라도, 처음부터 그 개수만큼 스레드 풀을 생성하지는 않는다. 다시 말해서, 스레드가 부족할 경우 스레드를 증가하는 방식을 사용한다.

## 참고

* [https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html)
* [https://www.thinkingparallel.com/2007/07/31/10-ways-to-reduce-lock-contention-in-threaded-programs/](https://www.thinkingparallel.com/2007/07/31/10-ways-to-reduce-lock-contention-in-threaded-programs/)

